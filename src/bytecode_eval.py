from bytecode_gen import *
from parser import *



def execute_bytecode(insns, scope=None):
    if scope is None:
        scope = {}  # Initialize scope for variable bindings
    ip = 0
    operand = []
    
    def push(x):
        operand.append(x)
    
    def pop():
        return operand.pop()
    
    while True:
        opcode = insns[ip]
        if opcode == HALT:
            break
        elif opcode == NOP:
            pass
        elif opcode == PUSH:
            ip += 1
            byte_length = insns[ip]
            ip += 1
            num_bytes = insns[ip:ip+byte_length]
            ip += byte_length - 1
            value = int.from_bytes(num_bytes, byteorder='big', signed=True)
            push(value)
        elif opcode == ADD:
            r = pop()
            l = pop()
            push(l + r)
        elif opcode == SUB:
            r = pop()
            l = pop()
            push(l - r)
        elif opcode == MUL:
            r = pop()
            l = pop()
            push(l * r)
        elif opcode == NEG:
            l = pop()
            push(-l)
        elif opcode == DIV:
            r = pop()
            l = pop()
            push(l // r)
        elif opcode == MOD:
            r = pop()
            l = pop()
            push(l % r)
        elif opcode == POW:
            r = pop()
            l = pop()
            push(l ** r)
        elif opcode == LT:
            r = pop()
            l = pop()
            push(1 if l < r else 0)
        elif opcode == GT:
            r = pop()
            l = pop()
            push(1 if l > r else 0)
        elif opcode == EQ:
            r = pop()
            l = pop()
            push(1 if l == r else 0)
        elif opcode == NEQ:
            r = pop()
            l = pop()
            push(1 if l != r else 0)
        elif opcode == LE:
            r = pop()
            l = pop()
            push(1 if l <= r else 0)
        elif opcode == GE:
            r = pop()
            l = pop()
            push(1 if l >= r else 0)
        elif opcode == AND:
            r = pop()
            l = pop()
            push(1 if l and r else 0)
        elif opcode == OR:
            r = pop()
            l = pop()
            push(1 if l or r else 0)
        elif opcode == BAND:
            r = pop()
            l = pop()
            push(l & r)
        elif opcode == BOR:
            r = pop()
            l = pop()
            push(l | r)
        # elif opcode == BXOR:
        #     r = pop()
        #     l = pop()
        #     push(l ^ r)
        elif opcode == SHL:
            r = pop()
            l = pop()
            push(l << r)
        elif opcode == SHR:
            r = pop()
            l = pop()
            push(l >> r)
        elif opcode == NOT:
            l = pop()
            push(1 if not l else 0)
        elif opcode == BNOT:
            l = pop()
            push(~l)
        elif opcode == ASCII:
            l = pop()
            push(ord(l))
        elif opcode == CHAR:
            l = pop()
            push(chr(l))
        elif opcode == VARBIND:
            ip += 1
            name = insns[ip]  # Variable name
            value = pop()  # Value to bind
            scope[name] = value
        elif opcode == DISPLAY:
            value = pop()
            print(value, end="")
        elif opcode == DISPLAYL:
            value = pop()
            print(value)
        ip += 1
    
    return 

def execute_all(prog):
    ast, scope = parse(prog)
    bytecode = codegen(ast,scope)
    execute_bytecode(bytecode,scope)
if __name__ == "__main__":
    # Example input code
    input_code = """
 displayl ((5 + 3) * 2 - 4 / 2);
""" 

    # Parse the input code to generate an AST
    # ast, scope = parse(input_code)
    # pprint(ast)
    # pprint(scope)
    # # Generate bytecode from the AST
    # bytecode = codegen(ast,scope)

    # # Print the generated bytecode
    # print("Generated Bytecode:", bytecode)

    # # evaluated bytecode
    # print("Executed code:",execute_bytecode(bytecode,scope))
    execute_all(input_code)